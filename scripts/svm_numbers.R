# http://stackoverflow.com/questions/7121807/how-to-change-the-font-of-the-main-title-in-plot

windowsFonts(
  P001 = windowsFont("Andalus"),
  P002 = windowsFont("Angsana New"),
  P003 = windowsFont("Angsana New Bold"),
  P004 = windowsFont("Angsana New Bold Italic"),
  P005 = windowsFont("Angsana New Italic"),
  P006 = windowsFont("AngsanaUPC"),
  P007 = windowsFont("AngsanaUPC Bold"),
  P008 = windowsFont("AngsanaUPC Bold Italic"),
  P009 = windowsFont("AngsanaUPC Italic"),
  P010 = windowsFont("Arabic Typesetting"),
  P011 = windowsFont("Arial"),
  P012 = windowsFont("Arial Black"),
  P013 = windowsFont("Arial Bold"),
  P014 = windowsFont("Arial Bold Italic"),
  P015 = windowsFont("Arial Italic"),
  P016 = windowsFont("Batang"),
  P017 = windowsFont("BatangChe"),
  P018 = windowsFont("Browallia New"),
  P019 = windowsFont("Browallia New Bold"),
  P020 = windowsFont("Browallia New Bold Italic"),
  P021 = windowsFont("Browallia New Italic"),
  P022 = windowsFont("BrowalliaUPC"),
  P023 = windowsFont("BrowalliaUPC Bold"),
  P024 = windowsFont("BrowalliaUPC Bold Italic"),
  P025 = windowsFont("BrowalliaUPC Italic"),
  P026 = windowsFont("Calibri"),
  P027 = windowsFont("Calibri Bold"),
  P028 = windowsFont("Calibri Bold Italic"),
  P029 = windowsFont("Calibri Italic"),
  P030 = windowsFont("Cambria"),
  P031 = windowsFont("Cambria Bold"),
  P032 = windowsFont("Cambria Bold Italic"),
  P033 = windowsFont("Cambria Italic"),
  P034 = windowsFont("Cambria Math"),
  P035 = windowsFont("Candara"),
  P036 = windowsFont("Candara Bold"),
  P037 = windowsFont("Candara Bold Italic"),
  P038 = windowsFont("Candara Italic"),
  P039 = windowsFont("Comic Sans MS"),
  P040 = windowsFont("Comic Sans MS Bold"),
  P041 = windowsFont("Consolas"),
  P042 = windowsFont("Consolas Bold"),
  P043 = windowsFont("Consolas Bold Italic"),
  P044 = windowsFont("Consolas Italic"),
  P045 = windowsFont("Constantia"),
  P046 = windowsFont("Constantia Bold"),
  P047 = windowsFont("Constantia Bold Italic"),
  P048 = windowsFont("Constantia Italic"),
  P049 = windowsFont("Corbel"),
  P050 = windowsFont("Corbel Bold"),
  P051 = windowsFont("Corbel Bold Italic"),
  P052 = windowsFont("Corbel Italic"),
  P053 = windowsFont("Cordia New"),
  P054 = windowsFont("Cordia New Bold"),
  P055 = windowsFont("Cordia New Bold Italic"),
  P056 = windowsFont("Cordia New Italic"),
  P057 = windowsFont("CordiaUPC"),
  P058 = windowsFont("CordiaUPC Bold"),
  P059 = windowsFont("CordiaUPC Bold Italic"),
  P060 = windowsFont("CordiaUPC Italic"),
  P061 = windowsFont("Courier"),
  P062 = windowsFont("Courier New"),
  P063 = windowsFont("Courier New Bold"),
  P064 = windowsFont("Courier New Bold Italic"),
  P065 = windowsFont("Courier New Italic"),
  P066 = windowsFont("DaunPenh"),
  P067 = windowsFont("David"),
  P068 = windowsFont("David Bold"),
  P069 = windowsFont("DFKai-SB"),
  P070 = windowsFont("DilleniaUPC"),
  P071 = windowsFont("DilleniaUPC Bold"),
  P072 = windowsFont("DilleniaUPC Bold Italic"),
  P073 = windowsFont("DilleniaUPC Italic"),
  P074 = windowsFont("DokChampa"),
  P075 = windowsFont("Dotum"),
  P076 = windowsFont("DotomChe"),
  P077 = windowsFont("Estrangelo Edessa"),
  P078 = windowsFont("EucrosiaUPC"),
  P079 = windowsFont("EucrosiaUPC Bold"),
  P080 = windowsFont("EucrosiaUPC Bold Italic"),
  P081 = windowsFont("EucrosiaUPC Italic"),
  P082 = windowsFont("Euphemia"),
  P083 = windowsFont("FangSong"),
  P084 = windowsFont("Franklin Gothic Medium"),
  P085 = windowsFont("Franklin Gothic Medium Italic"),
  P086 = windowsFont("FrankRuehl"),
  P087 = windowsFont("FreesiaUPC"),
  P088 = windowsFont("FreesiaUPC Bold"),
  P089 = windowsFont("FreesiaUPC Bold Italic"),
  P090 = windowsFont("FreesiaUPC Italic"),
  P091 = windowsFont("Gautami"),
  P092 = windowsFont("Georgia"),
  P093 = windowsFont("Georgia Bold"),
  P094 = windowsFont("Georgia Bold Italic"),
  P095 = windowsFont("Georgia Italic"),
  P096 = windowsFont("Gisha"),
  P097 = windowsFont("Gisha Bold"),
  P098 = windowsFont("Gulim"),
  P099 = windowsFont("GulimChe"),
  P100 = windowsFont("Gungsuh"),
  P101 = windowsFont("GungsuhChe"),
  P102 = windowsFont("Impact"),
  P103 = windowsFont("IrisUPC"),
  P104 = windowsFont("IrisUPC Bold"),
  P105 = windowsFont("IrisUPC Bold Italic"),
  P106 = windowsFont("IrisUPC Italic"),
  P107 = windowsFont("Iskoola Pota"),
  P108 = windowsFont("JasmineUPC"),
  P109 = windowsFont("JasmineUPC Bold"),
  P110 = windowsFont("JasmineUPC Bold Italic"),
  P111 = windowsFont("JasmineUPC Italic"),
  P112 = windowsFont("KaiTi"),
  P113 = windowsFont("Kalinga"),
  P114 = windowsFont("Kartika"),
  P115 = windowsFont("KodchiangUTC"),
  P116 = windowsFont("KodchiangUTC Bold"),
  P117 = windowsFont("KodchiangUTC Bold Italic"),
  P118 = windowsFont("KodchiangUTC Italic"),
  P119 = windowsFont("Latha"),
  P120 = windowsFont("Leelawadee"),
  P121 = windowsFont("Leelawadee Bold"),
  P122 = windowsFont("Levenim MT"),
  P123 = windowsFont("Levenim MT Bold"),
  P124 = windowsFont("LilyUPC"),
  P125 = windowsFont("LilyUPC Bold"),
  P126 = windowsFont("LilyUPC Bold Italic"),
  P127 = windowsFont("LilyUPC Italic"),
  P128 = windowsFont("Lucida Console"),
  P129 = windowsFont("Lucida Sans Unicode"),
  P130 = windowsFont("Malgun Gothic"),
  P131 = windowsFont("Malgun Gothic Bold"),
  P132 = windowsFont("Mangal"),
  P133 = windowsFont("Meiryo"),
  P134 = windowsFont("Meiryo Bold"),
  P135 = windowsFont("Meiryo Bold Italic"),
  P136 = windowsFont("Meiryo Italic"),
  P137 = windowsFont("Microsoft Himalaya"),
  P138 = windowsFont("Microsoft JhengHei"),
  P139 = windowsFont("Microsoft JhengHei Bold"),
  P140 = windowsFont("Microsoft Sans Serif"),
  P141 = windowsFont("Microsoft Uighur"),
  P142 = windowsFont("Microsoft YaHei"),
  P143 = windowsFont("Microsoft YaHei Bold"),
  P144 = windowsFont("Microsoft Yi Baiti"),
  P145 = windowsFont("MingLiU"),
  P146 = windowsFont("MingLiU-ExtB"),
  P147 = windowsFont("MingLiU_HKSCS"),
  P148 = windowsFont("MingLiU_HKSCS-ExtB"),
  P149 = windowsFont("Miriam"),
  P150 = windowsFont("Miriam Fixed"),
  P151 = windowsFont("Modern"),
  P152 = windowsFont("Mongolian Baiti"),
  P153 = windowsFont("MoolBoran"),
  P154 = windowsFont("MS Gothic"),
  P155 = windowsFont("MS Mincho"),
  P156 = windowsFont("MS PGothic"),
  P157 = windowsFont("MS PMincho"),
  P158 = windowsFont("MS Sans Saerif"),
  P159 = windowsFont("MS Serif"),
  P160 = windowsFont("MS UI Gothic"),
  P161 = windowsFont("MV Boli"),
  P162 = windowsFont("Narkisim"),
  P163 = windowsFont("NSimSun"),
  P164 = windowsFont("Nyala"),
  P165 = windowsFont("Palatino Linotype"),
  P166 = windowsFont("Palatino Linotype Bold"),
  P167 = windowsFont("Palatino Linotype Bold Italic"),
  P168 = windowsFont("Palatino Linotype Italic"),
  P169 = windowsFont("Plantagenet Cherokee"),
  P170 = windowsFont("PMingLiU"),
  P171 = windowsFont("PMingLiU-ExtB"),
  P172 = windowsFont("Raavi"),
  P173 = windowsFont("Rod"),
  P174 = windowsFont("Roman"),
  P175 = windowsFont("Script"),
  P176 = windowsFont("Segoe Print"),
  P177 = windowsFont("Segoe Print Bold"),
  P178 = windowsFont("Segoe Script"),
  P179 = windowsFont("Segoe Script Bold"),
  P180 = windowsFont("Segoe UI"),
  P181 = windowsFont("Segoe UI Bold"),
  P182 = windowsFont("Segoe UI Bold Italic"),
  P183 = windowsFont("Segoe UI Italic"),
  P184 = windowsFont("Shruti"),
  P185 = windowsFont("SimHei"),
  P186 = windowsFont("Simplified Arabic"),
  P187 = windowsFont("Simplified Arabic Bold"),
  P188 = windowsFont("Simplified Arabic Fixed"),
  P189 = windowsFont("SimSun"),
  P190 = windowsFont("SimSun-ExtB"),
  P191 = windowsFont("Small Fonts"),
  P192 = windowsFont("Sylfaen"),
  P193 = windowsFont("Symbol"),
  P194 = windowsFont("Tahoma"),
  P195 = windowsFont("Tahoma Bold"),
  P196 = windowsFont("Times New Roman"),
  P197 = windowsFont("Times New Roman Bold"),
  P198 = windowsFont("Times New Roman Bold Italic"),
  P199 = windowsFont("Times New Roman Italic"),
  P200 = windowsFont("Traditional Arabic"),
  P201 = windowsFont("Traditional Arabic Bold"),
  P202 = windowsFont("Trebuchet MS"),
  P203 = windowsFont("Trebuchet MS Bold"),
  P204 = windowsFont("Trebuchet MS Bold Italic"),
  P205 = windowsFont("Trebuchet MS Italic"),
  P206 = windowsFont("Tunga"),
  P207 = windowsFont("Verdana"),
  P208 = windowsFont("Verdana Bold"),
  P209 = windowsFont("Verdana Bold Italic"),
  P210 = windowsFont("Verdana Italic"),
  P211 = windowsFont("Vrinda")
)


# Considerar sólo las primeras 200 fuentes y hacer 10 gráficos 25x8 con los números
# en distintas fuentes.

# PRUEBAS -----------------------------------------------------------------

filename <- paste("/home/ibon/Escritorio/svm/ejercicio/numeros/prueba_8.png", sep = "")
  png(filename = filename, width = 30, height = 30)
  par(mfrow = c(1, 1), mar = c(0,0,0,0))
  plot(-1, -1, xlim = c(0, 1), ylim = c(0, 1), axes = FALSE)
  text(x = 0.5, y = 0.5, 8, cex = 3)    
dev.off()
filename <- paste("/home/ibon/Escritorio/svm/ejercicio/numeros/prueba_1.png", sep = "")
  png(filename = filename, width = 30, height = 30)
  par(mfrow = c(1, 1), mar = c(0,0,0,0))
  plot(-1, -1, xlim = c(0, 1), ylim = c(0, 1), axes = FALSE)
  text(x = 0.5, y = 0.5, 1, cex = 3)    
dev.off()

par(mfrow = c(2,1))
datos <- read.table(paste("/home/ibon/Escritorio/svm/ejercicio/numeros/prueba_8.txt", sep = ""), skip = 1, comment.char = "", sep = ":", stringsAsFactors = FALSE)
colores <- substring(text = datos[, 2], first = 26, last = 30)
aux <- ifelse(colores == "white", 0, 1)
plot(aux, type = "h", yaxt = "n", ylab = "", xlab = "variables", bty = "n")
datos <- read.table(paste("/home/ibon/Escritorio/svm/ejercicio/numeros/prueba_1.txt", sep = ""), skip = 1, comment.char = "", sep = ":", stringsAsFactors = FALSE)
colores <- substring(text = datos[, 2], first = 26, last = 30)
aux <- ifelse(colores == "white", 0, 1)
plot(aux, type = "h", yaxt = "n", ylab = "", xlab = "variables", bty = "n")

# GENERAMOS LAS IMÁGENES --------------------------------------------------

fuentes <- vector(mode = "character", 200)
for (i in 1:211) {
  fuentes[i] <- paste("P",substr("00", 1, 3 - nchar(as.character(i))), i, sep = "")
}

for (i in 1:200) {
  for (j in 0:9) {
    filename <- paste("M:/Carpetas personales/Ibon/svm/ejercicio/numeros/", j, "/", fuentes[i], ".png", sep = "")
    png(filename = filename, width = 30, height = 30)
      par(mfrow = c(1, 1), mar = c(0,0,0,0))
      plot(-1, -1, xlim = c(0, 1), ylim = c(0, 1), axes = FALSE)
      text(x = 0.5, y = 0.5, family = fuentes[i], j, cex = 3)    
    dev.off()
  }
}

# Gráfico para dibujar en una única imagen todos los números con todos 
# los tipos de letra. Habría entodes 10 gráficos, uno por cada número en el 
# que habría representado un total de 200 tipos de letra. Es claro que los 
# números no se diferencian mucho y esto hace que sea más fácil separar 
# entre los números.

par(mfrow = c(25, 8), mar = c(0,0,0,0))
# for (j in 0:9) {
  j <- 0
  for (i in 1:200) {
    plot(-1, -1, xlim = c(0, 1), ylim = c(0, 1), axes = FALSE)
    text(x = 0.5, y = 0.5, family = fuentes[i], j, cex = 3)    
  }
# }


# Si queremos entrenar a la máquina para distinguir entre vocales
# for (i in 1:211) {
#   for (j in c("a", "e", "i", "o", "u")) {
#     filename <- paste("C:/Documents and Settings/ibon/Escritorio/svm/ejercicio/vocales/", j, "/", fuentes[i], ".png", sep = "")
#     png(filename = filename, width = 50, height = 50)
#     par(mfrow = c(1, 1), mar = c(0,0,0,0))
#     plot(-1, -1, xlim = c(0, 1), ylim = c(0, 1), axes = FALSE)
#     text(x = 0.5, y = 0.5, family = fuentes[i], j, cex = 5)    
#     dev.off()
#   }
# }

# Hemos pasado las imágenes a texto
# mogrify -format txt *.png
# y ahora leemos los datos. La última columna 


fuentes <- vector(mode = "character", 200)
for (i in 1:213) {
  fuentes[i] <- paste("P",substr("00", 1, 3 - nchar(as.character(i))), i, sep = "")
}

lvalores <- vector(mode = "list", length = 10)
for (j in 0:9) {
  valores <- data.frame()
  for (i in fuentes[1:200]) {
    datos <- read.table(file = paste("/home/ibon/Escritorio/svm/ejercicio/numeros/", j, "/", i, ".txt", sep = ""), 
                        skip = 1, 
                        comment.char = "", 
                        sep = ":", 
                        stringsAsFactors = FALSE)
    colores <- substring(text = datos[, 2], first = 26, last = 30)
    aux <- ifelse(colores == "white", 0, 1)
    valores <- rbind(valores, as.data.frame(t(aux)))
  }  
  lvalores[[j+1]] <- valores
}

plot(apply(X = valores, MARGIN = 2, FUN = "mean"), 
     type = "h", main = "number 0", 
     xaxt = "n", yaxt = "n", 
     ylab = "", xlab = "variables", bty = "n")
axis(1, at = seq(0, 900, by = 100), labels = seq(0, 900, 100))

# Dibujamos el perfil promedio de cada número. Las figuras, generadas 
# a 30x30 pixeles de resolución nos dan un total de 900 variables en las que
# tenemos los valores "white" o "black". Nosotros pasaremos estos valores a
# 0 y 1. Cuanto mayor sea la resolución de la imagen mayor será también 
# el número de variables. Las diferencias claras entre los distintos números, 
# que hace que seamos capaces de distinguirlos, tienen que verse también 
# en el perfil generado por las 900 variables y estas diferencias son las 
# que tiene que encontrar la Máquina de Vector Soporte.

X11(15, 7)
par(mfrow = c(5, 2), mar = c(3.3, 0.5, 1.4, 0.5))
for (j in 1:10) {
  plot(apply(X = lvalores[[j]], MARGIN = 2, FUN = "mean"), 
       type = "h", main = paste("number",j-1, sep = " "), 
       xaxt = "n", yaxt = "n", 
       ylab = "", xlab = "", bty = "n")
  axis(1, at = seq(0, 900, by = 100), labels = seq(0, 900, 100))
}

# Creamos una base de datos de training y validación

number1 <- rep(seq(0, 9, 1), each = 150)
number2 <- rep(seq(0, 9, 1), each = 50)
number3 <- rep(seq(0, 9, 1), each = 10)

datos1 <- data.frame()
datos2 <- data.frame()
datos3 <- data.frame()
for (i in 1:10) {
  datos1 <- rbind(datos1, lvalores[[i]][1:150, ])
  datos2 <- rbind(datos2, lvalores[[i]][151:200, ])
  datos3 <- rbind(datos3, lvalores[[i]][1:10, ])
}
entrenamiento <- cbind(datos1, number = number1)
validacion <- cbind(datos2, number = number2)
prueba <- cbind(datos3, number = number3)

entrenamiento$number <- factor(entrenamiento$number, levels = seq(0, 9, 1))
validacion$number <- factor(validacion$number, levels = seq(0, 9, 1))
prueba$number <- factor(prueba$number, levels = seq(0, 9, 1))

rm(datos1, datos2, datos3, number1, number2, number3)

# LINUX #

windowsFonts(
  P001 = windowsFont("Abyssinica SIL"),
  P002 = windowsFont("Accanthis ADF Std"))

# Abyssinica SIL
# Accanthis ADF Std
# Accanthis ADF Std No2
# Accanthis ADF Std No3
# Amiri
# Asana Math
# Bigfish
# Bitstream Charter
# Cabin
# Century Schoolbook L
# Comfortaa
# Courier
# Courier 10 Pitch
# DejaVu Sans
# DejaVu Sans Condensed
# DejaVu Sans Light
# DejaVu Sans Mono
# Droid Sans
# Droid Sans Fallback
# Droid Sans Mono
# Droid Serif
# FreeMono
# FreeSans
# FreeSerif
# gargi
# Garuda
# Gentium
# Gentium Basic
# Gentium Book Basic
# GentiumAlt
# GFS Artemisia
# GFS Baskerville
# GFS Complutum
# GFS Didot
# GFS Didot Rg
# GFS Neohellenic Rg
# GFS Olga
# GFS Porson
# GFS Solomos
# Gillius ADF
# Gillius ADF Cd
# Gillius ADF No2
# Gillius ADF No2 Cd
# Helvetica
# Helvetica Condensed
# Helvetica Narrow
# Inconsolata
# IPAexGothic
# IPAexMincho
# IPAGothic
# IPAMincho
# IPAPGothic
# IPAPMincho
# Junicode
# KacstDecorative
# KacstOne
# Kedage
# Khmer OS
# Khmer OS System
# Kinnari
# Latin Modern Math
# Lato
# Lato Black
# Lato Hairline
# Lato Light
# Liberation Mono
# Liberation Sans
# Liberation Sans Narrow
# Liberation Serif
# Linux Biolinum Keyboard O
# Linux Biolinum O
# Linux Libertine Display O
# Linux Libertine Initials O
# Linux Libertine Mono O
# Linux Libertine O
# LM Mono 10
# LM Mono 12
# LM Mono 8
# LM Mono 9
# LM Mono Caps 10
# LM Mono Light 10
# LM Mono Prop 10
# LM Mono Prop Light 10
# LM Mono Slanted 10
# LM Roman 10
# LM Roman 12
# LM Roman 17
# LM Roman 5
# LM Roman 6
# LM Roman 7
# LM Roman 8
# LM Roman 9
# LM Roman Caps 10
# LM Roman Demi 10
# LM Roman Dunhill 10
# LM Roman Slanted 10
# LM Roman Slanted 12
# LM Roman Slanted 17
# LM Roman Slanted 8
# LM Roman Slanted 9
# LM Roman Unslanted 10
# LM Sans 10
# LM Sans 12
# LM Sans 17
# LM Sans 8
# LM Sans 9
# LM Sans Demi Cond 10
# LM Sans Quot 8
# Lobster Two
# Lohit Bengali
# Lohit Devanagari
# Lohit Gujarati
# Lohit Punjabi
# Lohit Tamil
# Loma
# Mallige
# MathJax_AMS
# MathJax_Caligraphic
# MathJax_Fraktur
# MathJax_Main
# MathJax_Math
# MathJax_SansSerif
# MathJax_Script
# MathJax_Size1
# MathJax_Size2
# MathJax_Size3
# MathJax_Size4
# MathJax_Typewriter
# Meera
# Mukti Narrow
# Mukti Narrow
# NanumBarunGothic
# NanumGothic
# NanumMyeongjo
# Nimbus Mono L
# Nimbus Roman No9 L
# Nimbus Sans L
# Norasi
# Noto Sans
# Noto Sans Devanagari
# Noto Sans Devanagari UI
# Noto Sans Khmer
# Noto Sans Khmer UI
# Noto Sans Lao
# Noto Sans Lao UI
# Noto Sans Tamil
# Noto Sans Tamil UI
# Noto Sans UI
# Noto Serif
# Noto Serif Lao
# OpenSymbol
# Oxygen Mono
# Oxygen-Sans
# Padauk
# Padauk Book
# Phetsarath OT
# Pothana2000
# Purisa
# Rachana
# Rekha
# Saab
# Sawasdee
# Standard Symbols L
# STIXGeneral
# STIXSizeFourSym
# STIXSizeOneSym
# STIXSizeThreeSym
# STIXSizeTwoSym
# Symbol
# TakaoPGothic
# TeX Gyre Adventor
# TeX Gyre Bonum
# TeX Gyre Chorus
# TeX Gyre Cursor
# TeX Gyre Heros
# TeX Gyre Heros Cn
# TeX Gyre Pagella
# TeX Gyre Schola
# TeX Gyre Termes
# TG Pagella Math
# TG Termes Math
# Tibetan Machine Uni
# Tlwg Typist
# Tlwg Typo
# TlwgMono
# TlwgTypewriter
# Ubuntu
# Ubuntu Condensed
# Ubuntu Light
# Ubuntu Medium
# Ubuntu Mono
# Umpush
# URW Bookman L
# URW Chancery L
# URW Gothic L
# URW Palladio L
# Utopia
# Vemana2000
# Waree
# WenQuanYi Micro Hei
# WenQuanYi Micro Hei Mono

# http://blog.revolutionanalytics.com/2012/09/how-to-use-your-favorite-fonts-in-r-charts.html

library("extrafont")
font_import()
fonts()
fonttable() 

fuentes <- vector(mode = "character", length(fonts()))
for (i in 1:211) {
  fuentes[i] <- paste("P",substr("00", 1, 3 - nchar(as.character(i))), i, sep = "")
}

for (i in 1:length(fonts())) {
  for (j in 0:9) {
    filename <- paste("/home/ibon/Escritorio/svm/ejercicio/numeros/", j, "/", fuentes[i], ".png", sep = "")
    png(filename = filename, width = 30, height = 30)
    par(mfrow = c(1, 1), mar = c(0,0,0,0))
    plot(-1, -1, xlim = c(0, 1), ylim = c(0, 1), axes = FALSE)
    text(x = 0.5, y = 0.5, family = fonts()[i], j, cex = 3)    
    dev.off()
  }
}


j <- 8
par(mfrow = c(13, 10), mar = c(0, 0, 0, 0))
for (i in 1:130) {
  plot(-1, -1, xlim = c(0, 1), ylim = c(0, 1), axes = FALSE)
  text(x = 0.5, y = 0.5, family = fonts()[i], j, cex = 3)    
}


# SVM - MÁQUINAS DE VECTOR SOPORTE ----------------------------------------

## Support Vector Machine Learning

# Como ya hemos comentado, las máquinas de vector soporte dependen de la función kernel que consideremos. Las más usuales son las funciones kernel lineales y las funciones kernel de base radial [@JSSv015i09]. 
# 
# Vamos a entrenar dos máquinas de vector soporte a nuestros datos (consideraremos los tres tipos de imputaciones) con dos funciones kernel: lineal y radial.

### Linear Support Vector Machine

# Estimamos la exactitud de una máquina de vector soporte con función kernel lineal. La forma de atacar este problema por parte de la librería `caret` [@JSSv028i05; @caret2015] es evaluando cada punto de la malla generada por los diferentes valores de los parámetros *sigma* ($\sigma$) y *costo* ($c$). Una vez  evaluados todos los paŕametros elegiremos aquél par (*sigma*, *costo*) que hayan maximizado la exactitud de las predicciones. Valoramos la construcción del modelo considerando 5 repeticiones con el 80% del total de la muestra (`trainControl(method = "cv", p = 0.8, number = 5, repeats = 5, search = "grid")`). Para evaluar un modelo de máquinas de vector soporte con kernel lineal, le pasamos a la función `train` el argumento `method = "svmLinear2"` que será evaluada internamente con las funciones del paquete `kernlab` [@kernlab2004].
# 
# En metabolómica, es habitual realizar diferentes transformaciones en los datos para conseguir distribuciones normales o distribuciones tipificadas entre otras muchas [@vandenBerg2006]. Vamos a construir las máquinas de vector soporte con tres tipos de procesado a los datos:
#   
# * Datos originales, `preProcess = NULL`.
# * Datos escalados y centrados, `preProcess = c("scale", "center")`.
# * Datos transformados según potencias *BoxCox*, `preProcess = "BoxCox"`.
# 
# Tendremos entonces nueve máquinas de vector soporte que compararemos para ver cuál es el tipo de transformaciones y qué asignación de valores perdidos es la más conveniente para obtener la máxima exactitud. Este proceso lo repetiremos para intentar clasificar los cuatro tipos de diagnóstico, la agrupación en tres diagnósticos y la agrupación en dos diagnósticos.

library("caret")
library("lattice")
library("ggplot2")
library("e1071")
library("kernlab") # svmRadial

# http://topepo.github.io/caret/train-models-by-tag.html#Support_Vector_Machines

procesado <- list(NULL, c("scale", "center"), "BoxCox")

for (i in 1:900) prueba[, i] <- jitter(prueba[, i]) # Quitamos valores constantes
for (i in 1:900) entrenamiento[, i] <- jitter(entrenamiento[, i]) # Quitamos valores constantes

z <- as.matrix(matrix(unlist(prueba[37, 1:900]), ncol = 30))
graphics::image(as.matrix(z), col = heat.colors(10))

grises <- colorRampPalette(colors = rev(c(gray(0), gray(0.1), gray(0.2), 
                                          gray(0.3), gray(0.4), gray(0.5), 
                                          gray(0.6), gray(0.7), gray(0.8), 
                                          gray(0.9), gray(1))))(10)

graphics::image(as.matrix(z), 
                col = grises
                )

modelo <- train(form = number ~ .,
                data = entrenamiento,
                method = "svmRadial",
                preProcess = procesado[[1]],
                trControl = trainControl(method = "cv",
                                         p = 0.8, number = 5,
                                         repeats = 5,
                                         search = "grid"),
                metric = "Accuracy",
                tuneLength = 5,
                maximize = TRUE)  

svmGrid <- expand.grid(sigma = round(seq(1e-5, 1e-2, length = 20), 5),
                       C = 2^seq(from = -2, to = 2, by = 1))

modelo <- train(form = number ~ .,
      data = entrenamiento,
      method = "svmRadial",
      preProcess = procesado[[1]],
      trControl = trainControl(method = "cv",
                               p = 0.8, number = 5,
                               repeats = 5,
                               search = "grid"),
      metric = "Accuracy",
      tuneGrid = svmGrid,
      maximize = TRUE)  


# predict(modelo, newdata)


mlplot <- function(svm, main = "") {
  AUX <- svm$results
  AUX$C <- log(AUX$C, base = 2)
  levelplot(Accuracy~C*sigma, data = AUX, 
            cuts = 20, pretty = TRUE, aspect = "fill",
            col.regions = colorRampPalette(c("red", "white", "green4")),
            xlab = expression(paste(log[2], "(C)", sep = "")), 
            xaxt = "n", 
            # contour = TRUE, labels = TRUE,
            main = main, cex.main = 0.7,
            ylab = expression(paste("sigma (", sigma, ")", sep = "")),
            colorkey = list(space = "right", 
                            col = colorRampPalette(c("red", "white", "green4"))))  
}

print(mlplot(modelo, main = "Sin procesado; mínimo"))

# Curiosidades

# https://es.wikipedia.org/wiki/Captcha

